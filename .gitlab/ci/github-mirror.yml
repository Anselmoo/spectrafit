github_insiders_push:
  stage: mirror
  image: alpine:latest
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0 # Full clone to ensure all git objects are available
    GITHUB_TARGET_BRANCH: "insiders"
  needs:
    - job: test-3.9
      artifacts: true
    - job: test-3.10
      artifacts: true
    - job: test-3.11
      artifacts: true
    - job: test-3.12
      artifacts: true
    - job: test-3.13
      artifacts: true
  script:
    - apk add --no-cache git curl

    # Configure git with secret identity
    - git config --global user.name "${GIT_COMMIT_USER_NAME}"
    - git config --global user.email "${GIT_COMMIT_USER_EMAIL}"

    # Store current commit hash before any operations
    - CURRENT_COMMIT=$(git rev-parse HEAD)
    - echo "üìç Current commit - $CURRENT_COMMIT"

    # Handle any uncommitted changes more robustly
    - echo "üßπ Handling uncommitted changes..."
    - |
      # Check if there are any uncommitted changes
      if ! git diff --quiet || ! git diff --cached --quiet; then
        echo "‚ö†Ô∏è Found uncommitted changes, stashing them..."
        git add -A
        git stash push -m "CI: temporary stash before mirror sync - $(date)"
        STASH_CREATED=true
      else
        echo "‚úÖ Working directory is clean"
        STASH_CREATED=false
      fi

    # Clean any untracked files
    - git clean -fdx

    # Add GitHub remote with access token
    - echo "üîó Setting up GitHub remote with credentials..."
    - |
      GITHUB_REPO_URL="https://x-access-token:${GITHUB_ACCESS_TOKEN}@github.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}.git"
      git remote add github "${GITHUB_REPO_URL}"

    # Fetch from both repositories
    - echo "üì• Fetching from repositories..."
    - git fetch --verbose github || echo "‚ö†Ô∏è Failed to fetch from GitHub"
    - git fetch --verbose origin || echo "‚ö†Ô∏è Failed to fetch from GitLab"

    # Create an improved connection between GitHub main and insiders
    - echo "üîÑ Creating connected history between main and insiders..."
    - |
      # Check if GitHub main branch exists
      if git ls-remote --heads github refs/heads/main | grep -q refs/heads/main; then
        echo "‚úÖ Found GitHub main branch, will use it as base"

        # Get GitHub main commit hash without creating branches
        GITHUB_MAIN_COMMIT=$(git rev-parse github/main)
        echo "üìç GitHub main commit - $GITHUB_MAIN_COMMIT"

        # Compare tree objects instead of using git diff with branches
        CURRENT_TREE=$(git show -s --format=%T $CURRENT_COMMIT)
        GITHUB_TREE=$(git show -s --format=%T $GITHUB_MAIN_COMMIT)

        if [ "$CURRENT_TREE" = "$GITHUB_TREE" ]; then
          echo "üü¢ GitHub main and GitLab main have identical content, pushing as is"
          git push --force github $CURRENT_COMMIT:${GITHUB_TARGET_BRANCH}
        else
          echo "üîÑ Content differences found, creating a connected commit"

          # Create a new commit with current tree but connected to GitHub history
          COMMIT_MSG="ci: üîß sync insiders branch with main updates

          This commit synchronizes the insiders branch with the latest changes
          from the main branch while maintaining connection to GitHub history.

          Original GitLab commit: $CURRENT_COMMIT
          GitHub main commit: $GITHUB_MAIN_COMMIT"

          NEW_COMMIT=$(git commit-tree $CURRENT_TREE -p $GITHUB_MAIN_COMMIT -m "$COMMIT_MSG")

          # Push this connected commit to GitHub insiders
          git push --force github $NEW_COMMIT:${GITHUB_TARGET_BRANCH}

          echo "‚úÖ Successfully pushed connected commit: $NEW_COMMIT"
        fi
      else
        # Fallback - no GitHub main history to connect to
        echo "‚ö†Ô∏è GitHub main branch not found, creating insiders from scratch"
        git push --force github $CURRENT_COMMIT:${GITHUB_TARGET_BRANCH}
      fi

    # Restore any stashed changes if we created a stash
    - |
      if [ "$STASH_CREATED" = "true" ]; then
        echo "üîÑ Restoring stashed changes..."
        git stash pop || echo "‚ö†Ô∏è Failed to restore stash"
      else
        echo "‚ÑπÔ∏è No stash to restore"
      fi

  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "insiders"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "insiders"'
      when: always
  dependencies: []
  allow_failure: false
  tags:
    - shared
