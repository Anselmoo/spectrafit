"""Coverage Analysis Tool for SpectraFit.

This script analyzes the coverage.json file generated by pytest-cov and identifies
which parts of the codebase need more test coverage. It prioritizes modules and functions
with no or minimal coverage.
"""

from __future__ import annotations

import json
import logging
import subprocess
import sys

from pathlib import Path
from typing import Any


# Constants
HIGH_COVERAGE_THRESHOLD = 90
PERFECT_COVERAGE_THRESHOLD = 100.0
COVERAGE_FILE = "coverage.json"
BACKUP_COVERAGE_FILE = "coverage_old.json"
PROJECT_PREFIX = "spectrafit/"

# Configure logging with a named logger
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")


def validate_command(cmd: list[str]) -> bool:
    """Validate command parameters for safety.

    Args:
        cmd: list of command components to validate.

    Returns:
        True if the command is safe to execute, False otherwise.
    """
    valid_commands = {"uv", "run", "pytest"}
    # Check if first element is a known command
    if cmd[0] not in valid_commands:
        return False

    # Validate each command argument for safety
    for arg in cmd:
        # Ensure arguments are safe
        if isinstance(arg, str) and (
            (arg.startswith("--") and not arg.startswith("--cov"))
            or ";" in arg
            or "&" in arg
            or "|" in arg
        ):
            return False
    return True


def run_coverage_test() -> None:
    """Run pytest with coverage to generate the coverage.json file."""
    logger.info("Running pytest with coverage...")
    cmd = [
        "uv",
        "run",
        "pytest",
        PROJECT_PREFIX,
        f"--cov=./{PROJECT_PREFIX}",
        f"--cov-report=json:{COVERAGE_FILE}",
    ]

    try:
        if not validate_command(cmd):
            logger.error("Invalid command parameters detected")
            sys.exit(1)

        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        logger.info("Coverage report generated successfully.")
        logger.info("%s", result.stdout)
    except subprocess.CalledProcessError as e:
        logger.exception("Error running pytest")
        logger.exception("stdout: %s", e.stdout)
        logger.exception("stderr: %s", e.stderr)
        sys.exit(1)


def load_coverage_data() -> dict[str, Any]:
    """Load the coverage data from coverage.json.

    Returns:
        dictionary containing the coverage data.

    Raises:
        SystemExit: If the coverage file can't be loaded or decoded.
    """
    try:
        with Path(COVERAGE_FILE).open(encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        logger.info("%s not found. Running pytest with coverage...", COVERAGE_FILE)
        run_coverage_test()
        return load_coverage_data()
    except json.JSONDecodeError:
        logger.exception("Error decoding %s. It might be corrupted.", COVERAGE_FILE)
        sys.exit(1)


def parse_coverage_data(data: dict[str, Any]) -> list[dict[str, Any]]:
    """Parse the coverage data to extract uncovered lines and functions for each file.

    Args:
        data: dictionary containing the coverage data.

    Returns:
        A list of dictionaries with file information, sorted by coverage percentage.
    """
    results = []

    for filename, file_data in data["files"].items():
        if not filename.startswith(PROJECT_PREFIX):
            continue

        total_lines = sum(file_data["executed_lines"]) + sum(file_data["missing_lines"])
        covered_lines = sum(file_data["executed_lines"])
        coverage_percent = (covered_lines / total_lines * 100) if total_lines > 0 else 0

        missing_lines: list[int] = []
        missing_lines.extend(
            i + 1
            for i, executed in enumerate(file_data["executed_lines"])
            if not executed and i + 1 in file_data["missing_lines"]
        )
        results.append(
            {
                "filename": filename,
                "coverage": coverage_percent,
                "missing_lines": missing_lines,
                "missing_branches": file_data.get("missing_branches", []),
                "excluded_lines": file_data.get("excluded_lines", []),
            }
        )

    # Sort by coverage percentage (ascending)
    return sorted(results, key=lambda x: x["coverage"])


def get_file_content(filename: str) -> list[str]:
    """Get the content of a file as a list of lines.

    Args:
        filename: Path to the file to read.

    Returns:
        list of lines in the file, or empty list if file not found.
    """
    try:
        with Path(filename).open(encoding="utf-8") as f:
            return f.readlines()
    except FileNotFoundError:
        logger.warning("File not found: %s", filename)
        return []


def identify_uncovered_functions(
    filename: str, missing_lines: list[int]
) -> list[tuple[str, int, int]]:
    """Identify uncovered functions in a file based on missing lines.

    Args:
        filename: Path to the Python file to analyze.
        missing_lines: list of line numbers that are not covered by tests.

    Returns:
        A list of tuples containing (function_name, start_line, end_line).
    """
    if not (lines := get_file_content(filename)):
        return []

    functions = []
    current_function = None
    start_line = 0
    indent_level = 0

    for i, line in enumerate(lines):
        line_num = i + 1
        stripped = line.strip()

        # Check if this is a function definition
        if stripped.startswith("def ") and ":" in stripped:
            function_name = stripped[4:].split("(")[0].strip()
            current_function = function_name
            start_line = line_num
            indent_level = len(line) - len(line.lstrip())

        # Check if we're exiting a function (by finding a line with same or less indentation)
        elif (
            current_function
            and not stripped.startswith("#")
            and stripped
            and len(line) - len(line.lstrip()) <= indent_level
        ):
            # Only add if the function contains missing lines
            if any(start_line <= ml <= line_num - 1 for ml in missing_lines):
                functions.append((current_function, start_line, line_num - 1))
            current_function = None

    # Handle the last function in the file
    if current_function and any(start_line <= ml for ml in missing_lines):
        functions.append((current_function, start_line, len(lines)))

    return functions


def generate_test_suggestions(file_data: list[dict[str, Any]]) -> dict[str, list[str]]:
    """Generate suggestions for tests to improve coverage.

    Args:
        file_data: list of dictionaries containing file coverage information.

    Returns:
        A dictionary mapping module names to lists of test suggestions.
    """
    suggestions: dict[str, list[str]] = {}

    for file_info in file_data:
        if file_info["coverage"] >= HIGH_COVERAGE_THRESHOLD:
            # Skip files with high coverage
            continue

        filename = file_info["filename"]
        module_name = Path(filename).name.replace(".py", "")

        # Identify uncovered functions
        uncovered_functions = identify_uncovered_functions(
            filename, file_info["missing_lines"]
        )

        if not uncovered_functions:
            continue

        test_path = f"{PROJECT_PREFIX}test/test_{module_name}.py"
        test_exists = Path(test_path).exists()

        suggestions[module_name] = []

        # Generate suggestions based on uncovered functions
        for func_name, start_line, end_line in uncovered_functions:
            test_action = (
                "Extend existing test file at"
                if test_exists
                else "Create new test file at"
            )
            suggestion = ("Function `%s` (lines %d-%d) needs test coverage. %s %s") % (
                func_name,
                start_line,
                end_line,
                test_action,
                test_path,
            )
            suggestions[module_name].append(suggestion)

    return suggestions


def analyze_coverage_improvement(
    old_data: dict[str, Any], new_data: dict[str, Any]
) -> dict[str, Any]:
    """Compare old and new coverage data to see improvements.

    Args:
        old_data: Coverage data from previous run.
        new_data: Coverage data from current run.

    Returns:
        dictionary mapping filenames to lists of newly covered lines.
    """
    results = {}

    for filename, file_data in new_data["files"].items():
        if not filename.startswith(PROJECT_PREFIX):
            continue

        old_file_data = old_data["files"].get(filename, {})
        old_missing = set(old_file_data.get("missing_lines", []))
        new_missing = set(file_data.get("missing_lines", []))

        newly_covered = old_missing - new_missing
        if newly_covered:
            results[filename] = list(newly_covered)

    return results


def print_summary(
    file_data: list[dict[str, Any]], suggestions: dict[str, list[str]]
) -> None:
    """Print a summary of the coverage analysis.

    Args:
        file_data: list of dictionaries containing file coverage information.
        suggestions: dictionary mapping module names to lists of test suggestions.
    """
    logger.info("\n=== Coverage Analysis Summary ===\n")

    # Overall stats
    total_coverage = (
        sum(f["coverage"] for f in file_data) / len(file_data) if file_data else 0
    )
    logger.info("Overall Coverage: %.2f%%", total_coverage)

    # Files with less than perfect coverage
    logger.info("\nFiles Needing Coverage Optimization:")
    for file_info in file_data:
        if file_info["coverage"] < PERFECT_COVERAGE_THRESHOLD:
            logger.info("  - %s: %.2f%%", file_info["filename"], file_info["coverage"])

    # Test suggestions
    logger.info("\nSuggested Test Improvements:")
    for module, module_suggestions in suggestions.items():
        logger.info("\n%s.py:", module)
        for suggestion in module_suggestions:
            logger.info("  - %s", suggestion)


def find_test_file(module_name: str) -> str | None:
    """Find the test file for a given module.

    Args:
        module_name: Name of the module to find tests for.

    Returns:
        Path to the test file if it exists, None otherwise.
    """
    test_path = f"{PROJECT_PREFIX}test/test_{module_name}.py"
    return test_path if Path(test_path).exists() else None


def main() -> None:
    """Run th the coverage analysis."""
    # Save the current coverage data for comparison
    if Path(COVERAGE_FILE).exists():
        try:
            with Path(COVERAGE_FILE).open(encoding="utf-8") as f:
                old_data = json.load(f)
            with Path(BACKUP_COVERAGE_FILE).open("w", encoding="utf-8") as f:
                json.dump(old_data, f)
        except Exception:
            logger.exception("Failed to backup coverage data")

    # Run the coverage tests
    run_coverage_test()

    # Load and parse the coverage data
    data = load_coverage_data()
    file_data = parse_coverage_data(data)

    # Generate test suggestions
    suggestions = generate_test_suggestions(file_data)

    # Print summary
    print_summary(file_data, suggestions)

    # Compare with previous run if available
    if Path(BACKUP_COVERAGE_FILE).exists():
        try:
            with Path(BACKUP_COVERAGE_FILE).open(encoding="utf-8") as f:
                old_data = json.load(f)
            if improvements := analyze_coverage_improvement(old_data, data):
                logger.info("\nCoverage Improvements:")
                for filename, lines in improvements.items():
                    logger.info("  - %s: %d newly covered lines", filename, len(lines))
        except Exception:
            logger.exception("Failed to analyze coverage improvement")


if __name__ == "__main__":
    main()
